<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>é™¤å¤œã®é˜ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° - å®‡å®™ç·¨</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
    }

    #gameContainer {
      position: relative;
      touch-action: none;
    }

    #gameCanvas {
      display: block;
      background: linear-gradient(to bottom, #0a0a2e 0%, #1a1a4e 50%, #0a0a2e 100%);
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: #fff;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }

    #startScreen, #gameOverScreen, #clearScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      text-align: center;
    }

    .screen-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #ffd700;
    }

    .screen-subtitle {
      font-size: 1.2em;
      margin-bottom: 30px;
      color: #aaa;
    }

    .start-button {
      padding: 15px 50px;
      font-size: 1.3em;
      background: linear-gradient(to bottom, #ffd700, #ff8c00);
      border: none;
      border-radius: 10px;
      color: #000;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .start-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px #ffd700;
    }

    .instructions {
      margin-top: 30px;
      font-size: 0.9em;
      color: #888;
      line-height: 1.8;
    }

    .hidden {
      display: none !important;
    }

    #phaseAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #ffd700;
      text-shadow: 0 0 30px #ffd700;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .bell-counter {
      font-size: 1.5em;
      color: #ffd700;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <div>
        <div class="bell-counter">ğŸ”” <span id="bellCount">0</span> / 108</div>
        <div id="phaseDisplay">ç¬¬ä¸€ã®è©¦ç·´</div>
      </div>
      <div>
        <div>â¤ï¸ <span id="lives">3</span></div>
      </div>
    </div>

    <div id="phaseAnnounce"></div>

    <div id="startScreen">
      <div class="screen-title">ğŸ”” é™¤å¤œã®é˜ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</div>
      <div class="screen-subtitle">ã€œ å®‡å®™ç·¨ ã€œ</div>
      <button class="start-button" id="startButton">å§‹ã‚ã‚‹</button>
      <div class="instructions">
        ç§»å‹•: â† â†’ / A D / ãƒã‚¦ã‚¹ / ã‚¿ãƒƒãƒ<br>
        æ”»æ’ƒ: ã‚¹ãƒšãƒ¼ã‚¹ / ã‚¯ãƒªãƒƒã‚¯ / ã‚¿ãƒƒãƒ—<br><br>
        108å›é˜ã‚’æ‰“ã£ã¦ç…©æ‚©ã‚’æ‰•ãŠã†ï¼
      </div>
    </div>

    <div id="gameOverScreen" class="hidden">
      <div class="screen-title">ğŸ’€ ç…©æ‚©ã«è² ã‘ãŸ...</div>
      <div class="screen-subtitle">æ‰“ã£ãŸé˜: <span id="finalBellCount">0</span>å›</div>
      <button class="start-button" id="retryButton">ã‚‚ã†ä¸€åº¦</button>
    </div>

    <div id="clearScreen" class="hidden">
      <div class="screen-title">ğŸŠ ç…©æ‚©é€€æ•£ï¼</div>
      <div class="screen-subtitle">108ã®é˜ã‚’æ‰“ã¡é³´ã‚‰ã—ãŸï¼</div>
      <button class="start-button" id="clearRetryButton">ã‚‚ã†ä¸€åº¦éŠã¶</button>
    </div>
  </div>

  <script>
    // ===== ã‚²ãƒ¼ãƒ è¨­å®š =====
    const CONFIG = {
      PLAYER_SPEED: 8,
      HAMMER_SPEED: 12,
      HAMMER_COOLDOWN: 200,
      MAX_BELLS: 108,
      INITIAL_LIVES: 3,
      PHASES: [
        { name: 'ç¬¬ä¸€ã®è©¦ç·´', start: 0, end: 35, spawnRate: 1500, spread: false },
        { name: 'ç¬¬äºŒã®è©¦ç·´', start: 36, end: 71, spawnRate: 1200, spread: true },
        { name: 'æœ€çµ‚è©¦ç·´', start: 72, end: 107, spawnRate: 800, spread: true, barrage: true }
      ],
      BONNOU_TYPES: [
        { name: 'å‚²', color: '#00bfff', speed: 2, size: 30, behavior: 'normal' },
        { name: 'æ€’', color: '#ff4444', speed: 4, size: 25, behavior: 'fast' },
        { name: 'æ¬²', color: '#9932cc', speed: 1.5, size: 45, behavior: 'large' },
        { name: 'å¦¬', color: '#32cd32', speed: 2.5, size: 28, behavior: 'homing' },
        { name: 'æƒ°', color: '#ffd700', speed: 1.8, size: 32, behavior: 'wave' }
      ]
    };

    // ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ =====
    const game = {
      state: 'start', // start, playing, gameover, clear
      bellCount: 0,
      lives: CONFIG.INITIAL_LIVES,
      phase: 0,
      lastSpawn: 0,
      lastHammer: 0,
      stars: [],
      hammers: [],
      bonnous: [],
      particles: [],
      bellRings: []
    };

    // ===== Canvas è¨­å®š =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const maxWidth = Math.min(window.innerWidth, 600);
      const maxHeight = Math.min(window.innerHeight, 800);

      width = maxWidth;
      height = maxHeight;

      canvas.width = width;
      canvas.height = height;
      container.style.width = width + 'px';
      container.style.height = height + 'px';
    }

    // ===== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ =====
    const player = {
      x: 0,
      y: 0,
      width: 50,
      height: 60,
      targetX: 0,

      init() {
        this.x = width / 2;
        this.y = height - 100;
        this.targetX = this.x;
      },

      update() {
        // å…¥åŠ›ã«å¿œã˜ã¦ç§»å‹•
        if (input.left) this.targetX -= CONFIG.PLAYER_SPEED;
        if (input.right) this.targetX += CONFIG.PLAYER_SPEED;
        if (input.mouseX !== null) this.targetX = input.mouseX;

        // ç”»é¢å†…ã«åˆ¶é™
        this.targetX = Math.max(this.width / 2, Math.min(width - this.width / 2, this.targetX));

        // ã‚¹ãƒ ãƒ¼ã‚ºã«ç§»å‹•
        this.x += (this.targetX - this.x) * 0.15;
      },

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // è¢ˆè£Ÿï¼ˆä½“ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.ellipse(0, 10, 20, 25, 0, 0, Math.PI * 2);
        ctx.fill();

        // é ­
        ctx.fillStyle = '#ffdab9';
        ctx.beginPath();
        ctx.arc(0, -20, 18, 0, Math.PI * 2);
        ctx.fill();

        // åŠä¸»é ­ã®å…‰æ²¢
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(-5, -25, 8, 0, Math.PI * 2);
        ctx.fill();

        // ç›®
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-6, -18, 3, 0, Math.PI * 2);
        ctx.arc(6, -18, 3, 0, Math.PI * 2);
        ctx.fill();

        // å£ï¼ˆç‘æƒ³çš„ãªï¼‰
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -10, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();

        ctx.restore();
      }
    };

    // ===== å…¥åŠ›ç®¡ç† =====
    const input = {
      left: false,
      right: false,
      fire: false,
      mouseX: null
    };

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = true;
      if (e.key === ' ') {
        e.preventDefault();
        input.fire = true;
      }
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = false;
      if (e.key === ' ') input.fire = false;
    });

    // ãƒã‚¦ã‚¹
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.clientX - rect.left;
    });

    canvas.addEventListener('mouseleave', () => {
      input.mouseX = null;
    });

    canvas.addEventListener('click', () => {
      if (game.state === 'playing') fireHammer();
    });

    // ã‚¿ãƒƒãƒ
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.touches[0].clientX - rect.left;
    });

    canvas.addEventListener('touchend', () => {
      input.mouseX = null;
    });

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.touches[0].clientX - rect.left;
      if (game.state === 'playing') fireHammer();
    });

    // ===== ãƒãƒ³ãƒãƒ¼ =====
    function fireHammer() {
      const now = Date.now();
      if (now - game.lastHammer < CONFIG.HAMMER_COOLDOWN) return;
      game.lastHammer = now;

      const currentPhase = CONFIG.PHASES[game.phase];

      // åŸºæœ¬ãƒãƒ³ãƒãƒ¼
      game.hammers.push({
        x: player.x,
        y: player.y - 30,
        vx: 0,
        vy: -CONFIG.HAMMER_SPEED,
        rotation: 0
      });

      // æ‹¡æ•£æ”»æ’ƒï¼ˆãƒ•ã‚§ãƒ¼ã‚º2ä»¥é™ï¼‰
      if (currentPhase.spread) {
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: -3,
          vy: -CONFIG.HAMMER_SPEED,
          rotation: 0
        });
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: 3,
          vy: -CONFIG.HAMMER_SPEED,
          rotation: 0
        });
      }

      // å¼¾å¹•ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ•ã‚§ãƒ¼ã‚º3ï¼‰
      if (currentPhase.barrage) {
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: -6,
          vy: -CONFIG.HAMMER_SPEED * 0.8,
          rotation: 0
        });
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: 6,
          vy: -CONFIG.HAMMER_SPEED * 0.8,
          rotation: 0
        });
      }
    }

    function updateHammers() {
      for (let i = game.hammers.length - 1; i >= 0; i--) {
        const h = game.hammers[i];
        h.x += h.vx;
        h.y += h.vy;
        h.rotation += 0.3;

        if (h.y < -30 || h.x < -30 || h.x > width + 30) {
          game.hammers.splice(i, 1);
        }
      }
    }

    function drawHammers() {
      game.hammers.forEach(h => {
        ctx.save();
        ctx.translate(h.x, h.y);
        ctx.rotate(h.rotation);

        // æŸ„
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(-3, -15, 6, 30);

        // é ­
        ctx.fillStyle = '#444';
        ctx.fillRect(-12, -20, 24, 12);

        ctx.restore();
      });
    }

    // ===== ç…©æ‚© =====
    function spawnBonnou() {
      const type = CONFIG.BONNOU_TYPES[Math.floor(Math.random() * CONFIG.BONNOU_TYPES.length)];
      game.bonnous.push({
        x: Math.random() * (width - 60) + 30,
        y: -50,
        type: type,
        angle: 0,
        time: 0
      });
    }

    function updateBonnous() {
      for (let i = game.bonnous.length - 1; i >= 0; i--) {
        const b = game.bonnous[i];
        b.time++;

        switch (b.type.behavior) {
          case 'normal':
          case 'large':
            b.y += b.type.speed;
            break;
          case 'fast':
            b.y += b.type.speed;
            break;
          case 'homing':
            const dx = player.x - b.x;
            b.x += Math.sign(dx) * 1;
            b.y += b.type.speed;
            break;
          case 'wave':
            b.angle += 0.05;
            b.x += Math.sin(b.angle) * 3;
            b.y += b.type.speed;
            break;
        }

        // ç”»é¢å¤–ã§å‰Šé™¤
        if (b.y > height + 50) {
          game.bonnous.splice(i, 1);
        }
      }
    }

    function drawBonnous() {
      game.bonnous.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);

        // ç…©æ‚©ã®ä½“ï¼ˆã‚‚ã‚„ã‚‚ã‚„ï¼‰
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, b.type.size);
        gradient.addColorStop(0, b.type.color);
        gradient.addColorStop(0.7, b.type.color + '88');
        gradient.addColorStop(1, 'transparent');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, b.type.size, 0, Math.PI * 2);
        ctx.fill();

        // ç…©æ‚©ã®æ–‡å­—
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${b.type.size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.type.name, 0, 0);

        ctx.restore();
      });
    }

    // ===== è¡çªåˆ¤å®š =====
    function checkCollisions() {
      // ãƒãƒ³ãƒãƒ¼ vs ç…©æ‚©
      for (let hi = game.hammers.length - 1; hi >= 0; hi--) {
        const h = game.hammers[hi];
        for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
          const b = game.bonnous[bi];
          const dx = h.x - b.x;
          const dy = h.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < b.type.size + 10) {
            // ç…©æ‚©ã‚’å€’ã—ãŸ
            game.hammers.splice(hi, 1);
            game.bonnous.splice(bi, 1);
            game.bellCount++;

            // é˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            game.bellRings.push({
              x: b.x,
              y: b.y,
              radius: 0,
              alpha: 1
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            for (let p = 0; p < 8; p++) {
              game.particles.push({
                x: b.x,
                y: b.y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                color: b.type.color,
                life: 30
              });
            }

            // UIæ›´æ–°
            document.getElementById('bellCount').textContent = game.bellCount;

            // ãƒ•ã‚§ãƒ¼ã‚ºãƒã‚§ãƒƒã‚¯
            checkPhase();

            // ã‚¯ãƒªã‚¢ãƒã‚§ãƒƒã‚¯
            if (game.bellCount >= CONFIG.MAX_BELLS) {
              gameState('clear');
            }

            break;
          }
        }
      }

      // ç…©æ‚© vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
        const b = game.bonnous[bi];
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < b.type.size + 20) {
          game.bonnous.splice(bi, 1);
          game.lives--;
          document.getElementById('lives').textContent = game.lives;

          // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          for (let p = 0; p < 12; p++) {
            game.particles.push({
              x: player.x,
              y: player.y,
              vx: (Math.random() - 0.5) * 10,
              vy: (Math.random() - 0.5) * 10,
              color: '#ff0000',
              life: 40
            });
          }

          if (game.lives <= 0) {
            gameState('gameover');
          }
        }
      }
    }

    // ===== ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç† =====
    function checkPhase() {
      for (let i = CONFIG.PHASES.length - 1; i >= 0; i--) {
        if (game.bellCount >= CONFIG.PHASES[i].start) {
          if (game.phase !== i) {
            game.phase = i;
            announcePhase(CONFIG.PHASES[i].name);
            document.getElementById('phaseDisplay').textContent = CONFIG.PHASES[i].name;
          }
          break;
        }
      }
    }

    function announcePhase(name) {
      const el = document.getElementById('phaseAnnounce');
      el.textContent = name;
      el.style.opacity = 1;
      setTimeout(() => {
        el.style.opacity = 0;
      }, 2000);
    }

    // ===== ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ =====
    function updateParticles() {
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;

        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      game.particles.forEach(p => {
        ctx.fillStyle = p.color + Math.floor(p.life / 40 * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateBellRings() {
      for (let i = game.bellRings.length - 1; i >= 0; i--) {
        const r = game.bellRings[i];
        r.radius += 5;
        r.alpha -= 0.03;

        if (r.alpha <= 0) {
          game.bellRings.splice(i, 1);
        }
      }
    }

    function drawBellRings() {
      game.bellRings.forEach(r => {
        ctx.strokeStyle = `rgba(255, 215, 0, ${r.alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    // ===== èƒŒæ™¯ï¼ˆæ˜Ÿï¼‰ =====
    function initStars() {
      game.stars = [];
      for (let i = 0; i < 100; i++) {
        game.stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2 + 0.5,
          speed: Math.random() * 0.5 + 0.2
        });
      }
    }

    function updateStars() {
      game.stars.forEach(s => {
        s.y += s.speed;
        if (s.y > height) {
          s.y = 0;
          s.x = Math.random() * width;
        }
      });
    }

    function drawStars() {
      ctx.fillStyle = '#fff';
      game.stars.forEach(s => {
        ctx.globalAlpha = 0.5 + Math.random() * 0.5;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    // ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç† =====
    function gameState(state) {
      game.state = state;

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('clearScreen').classList.add('hidden');

      switch (state) {
        case 'start':
          document.getElementById('startScreen').classList.remove('hidden');
          break;
        case 'playing':
          resetGame();
          break;
        case 'gameover':
          document.getElementById('finalBellCount').textContent = game.bellCount;
          document.getElementById('gameOverScreen').classList.remove('hidden');
          break;
        case 'clear':
          document.getElementById('clearScreen').classList.remove('hidden');
          break;
      }
    }

    function resetGame() {
      game.bellCount = 0;
      game.lives = CONFIG.INITIAL_LIVES;
      game.phase = 0;
      game.lastSpawn = 0;
      game.lastHammer = 0;
      game.hammers = [];
      game.bonnous = [];
      game.particles = [];
      game.bellRings = [];

      player.init();
      initStars();

      document.getElementById('bellCount').textContent = '0';
      document.getElementById('lives').textContent = game.lives;
      document.getElementById('phaseDisplay').textContent = CONFIG.PHASES[0].name;
    }

    // ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
    function gameLoop(timestamp) {
      // èƒŒæ™¯ã‚¯ãƒªã‚¢
      ctx.fillStyle = '#0a0a2e';
      ctx.fillRect(0, 0, width, height);

      // æ˜Ÿ
      updateStars();
      drawStars();

      if (game.state === 'playing') {
        // ç…©æ‚©ã‚¹ãƒãƒ¼ãƒ³
        const currentPhase = CONFIG.PHASES[game.phase];
        if (timestamp - game.lastSpawn > currentPhase.spawnRate) {
          spawnBonnou();
          game.lastSpawn = timestamp;
        }

        // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é€£å°„
        if (input.fire) {
          fireHammer();
        }

        // æ›´æ–°
        player.update();
        updateHammers();
        updateBonnous();
        checkCollisions();
        updateParticles();
        updateBellRings();

        // æç”»
        drawBonnous();
        drawHammers();
        player.draw();
        drawParticles();
        drawBellRings();
      }

      requestAnimationFrame(gameLoop);
    }

    // ===== åˆæœŸåŒ– =====
    function init() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      initStars();
      player.init();

      // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
      document.getElementById('startButton').addEventListener('click', () => gameState('playing'));
      document.getElementById('retryButton').addEventListener('click', () => gameState('playing'));
      document.getElementById('clearRetryButton').addEventListener('click', () => gameState('playing'));

      gameState('start');
      requestAnimationFrame(gameLoop);
    }

    init();
  </script>
</body>
</html>
