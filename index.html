<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>é™¤å¤œã®é˜ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚° - å®‡å®™ç·¨</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
      font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
    }

    #gameContainer {
      position: relative;
      touch-action: none;
    }

    #gameCanvas {
      display: block;
      background: linear-gradient(to bottom, #0a0a2e 0%, #1a1a4e 50%, #0a0a2e 100%);
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: #fff;
      font-size: 16px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }

    #startScreen, #gameOverScreen, #clearScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      text-align: center;
    }

    .screen-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      text-shadow: 0 0 20px #ffd700;
    }

    .screen-subtitle {
      font-size: 1.2em;
      margin-bottom: 30px;
      color: #aaa;
    }

    .start-button {
      padding: 15px 50px;
      font-size: 1.3em;
      background: linear-gradient(to bottom, #ffd700, #ff8c00);
      border: none;
      border-radius: 10px;
      color: #000;
      cursor: pointer;
      font-weight: bold;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .start-button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px #ffd700;
    }

    .instructions {
      margin-top: 30px;
      font-size: 0.9em;
      color: #888;
      line-height: 1.8;
    }

    .hidden {
      display: none !important;
    }

    #phaseAnnounce {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #ffd700;
      text-shadow: 0 0 30px #ffd700;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .bell-counter {
      font-size: 1.5em;
      color: #ffd700;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
      <div>
        <div class="bell-counter">ğŸ”” <span id="bellCount">0</span> / 108</div>
        <div id="phaseDisplay">ç¬¬ä¸€ã®è©¦ç·´</div>
      </div>
      <div>
        <div>â¤ï¸ <span id="lives">3</span></div>
      </div>
    </div>

    <div id="phaseAnnounce"></div>

    <div id="startScreen">
      <div class="screen-title">ğŸ”” é™¤å¤œã®é˜ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</div>
      <div class="screen-subtitle">ã€œ å®‡å®™ç·¨ ã€œ</div>
      <button class="start-button" id="startButton">å§‹ã‚ã‚‹</button>
      <div class="instructions">
        ç§»å‹•: â† â†’ / A D / ãƒã‚¦ã‚¹ / ã‚¿ãƒƒãƒ<br>
        æ”»æ’ƒ: ã‚¹ãƒšãƒ¼ã‚¹ / ã‚¯ãƒªãƒƒã‚¯ / ã‚¿ãƒƒãƒ—<br><br>
        108å›é˜ã‚’æ‰“ã£ã¦ç…©æ‚©ã‚’æ‰•ãŠã†ï¼
      </div>
    </div>

    <div id="gameOverScreen" class="hidden">
      <div class="screen-title">ğŸ’€ ç…©æ‚©ã«è² ã‘ãŸ...</div>
      <div class="screen-subtitle">æ‰“ã£ãŸé˜: <span id="finalBellCount">0</span>å›</div>
      <button class="start-button" id="retryButton">ã‚‚ã†ä¸€åº¦</button>
    </div>

    <div id="clearScreen" class="hidden">
      <div class="screen-title">ğŸŠ ç…©æ‚©é€€æ•£ï¼</div>
      <div class="screen-subtitle">108ã®é˜ã‚’æ‰“ã¡é³´ã‚‰ã—ãŸï¼</div>
      <button class="start-button" id="clearRetryButton">ã‚‚ã†ä¸€åº¦éŠã¶</button>
    </div>
  </div>

  <script>
    // ===== ã‚²ãƒ¼ãƒ è¨­å®š =====
    const CONFIG = {
      PLAYER_SPEED: 8,
      HAMMER_SPEED: 12,
      HAMMER_COOLDOWN: 280,
      MAX_BELLS: 108,
      INITIAL_LIVES: 3,
      PHASES: [
        { name: 'ç¬¬ä¸€ã®è©¦ç·´', start: 0, end: 35, spawnRate: 700, spawnCount: 1, spread: false },
        { name: 'ç¬¬äºŒã®è©¦ç·´', start: 36, end: 71, spawnRate: 450, spawnCount: 2, spread: true },
        { name: 'æœ€çµ‚è©¦ç·´', start: 72, end: 107, spawnRate: 280, spawnCount: 3, spread: true, barrage: true }
      ],
      BONNOU_TYPES: [
        { name: 'å‚²', color: '#00bfff', speed: 3.5, size: 30, behavior: 'normal' },
        { name: 'æ€’', color: '#ff4444', speed: 6, size: 25, behavior: 'fast' },
        { name: 'æ¬²', color: '#9932cc', speed: 2.5, size: 50, behavior: 'large' },
        { name: 'å¦¬', color: '#32cd32', speed: 4, size: 28, behavior: 'homing' },
        { name: 'æƒ°', color: '#ffd700', speed: 3, size: 35, behavior: 'wave' }
      ],
      BOSS: {
        HP: 108,
        WIDTH: 120,
        HEIGHT: 150,
        SPEED: 4,
        BEAM_INTERVAL: 2000,
        BEAM_DURATION: 800,
        BEAM_WARNING: 500,
        SPAWN_INTERVAL: 600,
        SPAWN_COUNT: 2
      }
    };

    // ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ =====
    const game = {
      state: 'start', // start, playing, boss, gameover, clear
      bellCount: 0,
      lives: CONFIG.INITIAL_LIVES,
      phase: 0,
      lastSpawn: 0,
      lastHammer: 0,
      stars: [],
      hammers: [],
      bonnous: [],
      particles: [],
      bellRings: [],
      beams: []
    };

    // ===== ãƒœã‚¹ =====
    const boss = {
      x: 0,
      y: 0,
      hp: CONFIG.BOSS.HP,
      maxHp: CONFIG.BOSS.HP,
      direction: 1,
      lastBeam: 0,
      beamState: 'none', // none, warning, firing
      beamX: 0,
      beamTimer: 0,
      hitFlash: 0,
      lastSpawn: 0,
      // ãƒ©ãƒ³ãƒ€ãƒ å‹•ãç”¨
      speedMultiplier: 1,
      verticalOffset: 0,
      verticalDirection: 1,
      nextDirectionChange: 0,
      dashTimer: 0,
      isDashing: false,

      init() {
        this.x = width / 2;
        this.y = 120;
        this.hp = CONFIG.BOSS.HP;
        this.maxHp = CONFIG.BOSS.HP;
        this.direction = 1;
        this.lastBeam = 0;
        this.beamState = 'none';
        this.hitFlash = 0;
        this.lastSpawn = 0;
        this.speedMultiplier = 1;
        this.verticalOffset = 0;
        this.verticalDirection = 1;
        this.nextDirectionChange = 0;
        this.dashTimer = 0;
        this.isDashing = false;
      },

      update(timestamp) {
        // ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘è»¢æ›
        if (timestamp > this.nextDirectionChange) {
          if (Math.random() < 0.3) {
            this.direction *= -1;
          }
          // ãƒ©ãƒ³ãƒ€ãƒ ãªãƒ€ãƒƒã‚·ãƒ¥
          if (Math.random() < 0.2 && !this.isDashing) {
            this.isDashing = true;
            this.dashTimer = timestamp;
            this.speedMultiplier = 2.5;
          }
          this.nextDirectionChange = timestamp + 500 + Math.random() * 1000;
        }

        // ãƒ€ãƒƒã‚·ãƒ¥çµ‚äº†
        if (this.isDashing && timestamp - this.dashTimer > 300) {
          this.isDashing = false;
          this.speedMultiplier = 0.8 + Math.random() * 0.8;
        }

        // å·¦å³ç§»å‹•ï¼ˆãƒ©ãƒ³ãƒ€ãƒ é€Ÿåº¦ï¼‰
        const speed = CONFIG.BOSS.SPEED * this.speedMultiplier;
        this.x += speed * this.direction;

        // ç”»é¢ç«¯ã§åè»¢
        if (this.x > width - CONFIG.BOSS.WIDTH / 2 - 20) {
          this.x = width - CONFIG.BOSS.WIDTH / 2 - 20;
          this.direction = -1;
        } else if (this.x < CONFIG.BOSS.WIDTH / 2 + 20) {
          this.x = CONFIG.BOSS.WIDTH / 2 + 20;
          this.direction = 1;
        }

        // ä¸Šä¸‹ã®ã‚†ã‚‰ã
        this.verticalOffset += 0.5 * this.verticalDirection;
        if (Math.abs(this.verticalOffset) > 30) {
          this.verticalDirection *= -1;
        }
        this.y = 120 + this.verticalOffset + Math.sin(timestamp * 0.003) * 15;

        // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¸›è¡°
        if (this.hitFlash > 0) this.hitFlash--;

        // ç…©æ‚©ã‚’ã‚¹ãƒãƒ¼ãƒ³
        if (timestamp - this.lastSpawn > CONFIG.BOSS.SPAWN_INTERVAL) {
          this.spawnBonnouFromBoss();
          this.lastSpawn = timestamp;
        }

        // ãƒ“ãƒ¼ãƒ æ”»æ’ƒ
        if (this.beamState === 'none' && timestamp - this.lastBeam > CONFIG.BOSS.BEAM_INTERVAL) {
          this.beamState = 'warning';
          this.beamX = player.x;
          this.beamTimer = timestamp;
          this.lastBeam = timestamp;
        }

        if (this.beamState === 'warning' && timestamp - this.beamTimer > CONFIG.BOSS.BEAM_WARNING) {
          this.beamState = 'firing';
          this.beamTimer = timestamp;
        }

        if (this.beamState === 'firing' && timestamp - this.beamTimer > CONFIG.BOSS.BEAM_DURATION) {
          this.beamState = 'none';
        }

        // ãƒ“ãƒ¼ãƒ ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å½“ãŸã‚Šåˆ¤å®š
        if (this.beamState === 'firing') {
          const beamWidth = 60;
          if (Math.abs(player.x - this.beamX) < beamWidth / 2 + 20) {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
            game.lives--;
            document.getElementById('lives').textContent = game.lives;
            this.beamState = 'none';

            // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            for (let p = 0; p < 12; p++) {
              game.particles.push({
                x: player.x,
                y: player.y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                color: '#ff0000',
                life: 40
              });
            }

            if (game.lives <= 0) {
              gameState('gameover');
            }
          }
        }
      },

      spawnBonnouFromBoss() {
        const count = CONFIG.BOSS.SPAWN_COUNT;
        for (let i = 0; i < count; i++) {
          const type = CONFIG.BONNOU_TYPES[Math.floor(Math.random() * CONFIG.BONNOU_TYPES.length)];
          // é˜ã®ä¸‹ã‹ã‚‰ç…©æ‚©ãŒå‡ºç¾
          const offsetX = (Math.random() - 0.5) * CONFIG.BOSS.WIDTH;
          game.bonnous.push({
            x: this.x + offsetX,
            y: this.y + CONFIG.BOSS.HEIGHT / 2 + 20,
            type: type,
            angle: Math.random() * Math.PI * 2,
            time: 0,
            fromBoss: true // ãƒœã‚¹ã‹ã‚‰å‡ºãŸç…©æ‚©ãƒ•ãƒ©ã‚°
          });
        }
      },

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // ãƒ’ãƒƒãƒˆãƒ•ãƒ©ãƒƒã‚·ãƒ¥
        const flashColor = this.hitFlash > 0 ? '#fff' : null;

        // é˜æœ¬ä½“
        const gradient = ctx.createLinearGradient(-60, -60, 60, 60);
        gradient.addColorStop(0, flashColor || '#ffd700');
        gradient.addColorStop(0.5, flashColor || '#b8860b');
        gradient.addColorStop(1, flashColor || '#8b6914');

        // é˜ã®å½¢
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(-50, -50);
        ctx.quadraticCurveTo(-60, 0, -55, 50);
        ctx.lineTo(-60, 55);
        ctx.lineTo(60, 55);
        ctx.lineTo(55, 50);
        ctx.quadraticCurveTo(60, 0, 50, -50);
        ctx.quadraticCurveTo(0, -70, -50, -50);
        ctx.fill();

        // é˜ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.ellipse(-20, -20, 15, 25, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // é˜ã®ä¸‹ã®ç¸
        ctx.fillStyle = flashColor || '#daa520';
        ctx.fillRect(-62, 50, 124, 10);

        // æ’æœ¨ï¼ˆã—ã‚…ã‚‚ãï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.arc(0, 30, 12, 0, Math.PI * 2);
        ctx.fill();

        // ãƒœã‚¹ã®ç›®ï¼ˆæ€’ã‚Šï¼‰
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(-20, 0, 8, 0, Math.PI * 2);
        ctx.arc(20, 0, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-20, 0, 4, 0, Math.PI * 2);
        ctx.arc(20, 0, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // ãƒ“ãƒ¼ãƒ æç”»
        this.drawBeam();

        // HPãƒãƒ¼
        this.drawHPBar();
      },

      drawBeam() {
        if (this.beamState === 'none') return;

        const beamWidth = 60;

        if (this.beamState === 'warning') {
          // è­¦å‘Šè¡¨ç¤ºï¼ˆç‚¹æ»…ã™ã‚‹ç¸¦ç·šï¼‰
          ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.sin(Date.now() * 0.02) * 0.3})`;
          ctx.lineWidth = 4;
          ctx.setLineDash([10, 10]);
          ctx.beginPath();
          ctx.moveTo(this.beamX, this.y + 60);
          ctx.lineTo(this.beamX, height);
          ctx.stroke();
          ctx.setLineDash([]);

          // è­¦å‘Šã‚¨ãƒªã‚¢
          ctx.fillStyle = `rgba(255, 0, 0, ${0.1 + Math.sin(Date.now() * 0.02) * 0.1})`;
          ctx.fillRect(this.beamX - beamWidth / 2, this.y + 60, beamWidth, height - this.y - 60);
        }

        if (this.beamState === 'firing') {
          // ç…©æ‚©ãƒ“ãƒ¼ãƒ 
          const gradient = ctx.createLinearGradient(this.beamX - beamWidth / 2, 0, this.beamX + beamWidth / 2, 0);
          gradient.addColorStop(0, 'rgba(128, 0, 128, 0.8)');
          gradient.addColorStop(0.3, 'rgba(255, 0, 128, 0.9)');
          gradient.addColorStop(0.5, 'rgba(255, 100, 200, 1)');
          gradient.addColorStop(0.7, 'rgba(255, 0, 128, 0.9)');
          gradient.addColorStop(1, 'rgba(128, 0, 128, 0.8)');

          ctx.fillStyle = gradient;
          ctx.fillRect(this.beamX - beamWidth / 2, this.y + 60, beamWidth, height - this.y - 60);

          // ãƒ“ãƒ¼ãƒ ã®ç¸
          ctx.strokeStyle = '#ff00ff';
          ctx.lineWidth = 3;
          ctx.strokeRect(this.beamX - beamWidth / 2, this.y + 60, beamWidth, height - this.y - 60);

          // ç…©æ‚©ã®æ–‡å­—ãŒãƒ“ãƒ¼ãƒ å†…ã‚’æµã‚Œã‚‹
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 20px sans-serif';
          ctx.textAlign = 'center';
          const chars = ['æ€’', 'æ¬²', 'å¦¬', 'æƒ°', 'å‚²'];
          for (let i = 0; i < 5; i++) {
            const charY = ((Date.now() * 0.5 + i * 100) % (height - this.y - 60)) + this.y + 80;
            ctx.fillText(chars[i], this.beamX, charY);
          }
        }
      },

      drawHPBar() {
        const barWidth = 200;
        const barHeight = 20;
        const x = width / 2 - barWidth / 2;
        const y = 20;

        // èƒŒæ™¯
        ctx.fillStyle = '#333';
        ctx.fillRect(x, y, barWidth, barHeight);

        // HP
        const hpRatio = this.hp / this.maxHp;
        const hpColor = hpRatio > 0.5 ? '#ff4444' : hpRatio > 0.25 ? '#ff8800' : '#ff0000';
        ctx.fillStyle = hpColor;
        ctx.fillRect(x, y, barWidth * hpRatio, barHeight);

        // æ 
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);

        // ãƒ†ã‚­ã‚¹ãƒˆ
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`ç…©æ‚©å¤§é˜ ${this.hp}/${this.maxHp}`, width / 2, y + 15);
      },

      takeDamage() {
        this.hp--;
        this.hitFlash = 10;

        // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        for (let p = 0; p < 5; p++) {
          game.particles.push({
            x: this.x + (Math.random() - 0.5) * 100,
            y: this.y + (Math.random() - 0.5) * 100,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            color: '#ffd700',
            life: 30
          });
        }

        if (this.hp <= 0) {
          // ãƒœã‚¹æ’ƒç ´
          for (let p = 0; p < 50; p++) {
            game.particles.push({
              x: this.x + (Math.random() - 0.5) * 150,
              y: this.y + (Math.random() - 0.5) * 150,
              vx: (Math.random() - 0.5) * 15,
              vy: (Math.random() - 0.5) * 15,
              color: ['#ffd700', '#ff4444', '#ff00ff', '#00ffff'][Math.floor(Math.random() * 4)],
              life: 60
            });
          }
          gameState('clear');
        }
      }
    };

    // ===== Canvas è¨­å®š =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      const maxWidth = Math.min(window.innerWidth, 600);
      const maxHeight = Math.min(window.innerHeight, 800);

      width = maxWidth;
      height = maxHeight;

      canvas.width = width;
      canvas.height = height;
      container.style.width = width + 'px';
      container.style.height = height + 'px';
    }

    // ===== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ =====
    const player = {
      x: 0,
      y: 0,
      width: 50,
      height: 60,
      targetX: 0,

      init() {
        this.x = width / 2;
        this.y = height - 100;
        this.targetX = this.x;
      },

      update() {
        // ã‚­ãƒ¼æ“ä½œã‚’å„ªå…ˆï¼ˆã‚­ãƒ¼å…¥åŠ›ãŒã‚ã‚Œã°ãƒã‚¦ã‚¹ã¯ç„¡è¦–ï¼‰
        const keyPressed = input.left || input.right;

        if (keyPressed) {
          // ã‚­ãƒ¼æ“ä½œ
          if (input.left) this.targetX -= CONFIG.PLAYER_SPEED;
          if (input.right) this.targetX += CONFIG.PLAYER_SPEED;
        } else if (input.mouseX !== null) {
          // ãƒã‚¦ã‚¹æ“ä½œï¼ˆã‚­ãƒ¼å…¥åŠ›ãŒãªã„å ´åˆã®ã¿ï¼‰
          this.targetX = input.mouseX;
        }

        // ç”»é¢å†…ã«åˆ¶é™
        this.targetX = Math.max(this.width / 2, Math.min(width - this.width / 2, this.targetX));

        // ã‚¹ãƒ ãƒ¼ã‚ºã«ç§»å‹•
        this.x += (this.targetX - this.x) * 0.15;
      },

      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // è¢ˆè£Ÿï¼ˆä½“ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.ellipse(0, 10, 20, 25, 0, 0, Math.PI * 2);
        ctx.fill();

        // é ­
        ctx.fillStyle = '#ffdab9';
        ctx.beginPath();
        ctx.arc(0, -20, 18, 0, Math.PI * 2);
        ctx.fill();

        // åŠä¸»é ­ã®å…‰æ²¢
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(-5, -25, 8, 0, Math.PI * 2);
        ctx.fill();

        // ç›®
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-6, -18, 3, 0, Math.PI * 2);
        ctx.arc(6, -18, 3, 0, Math.PI * 2);
        ctx.fill();

        // å£ï¼ˆç‘æƒ³çš„ãªï¼‰
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, -10, 5, 0.2, Math.PI - 0.2);
        ctx.stroke();

        ctx.restore();
      }
    };

    // ===== å…¥åŠ›ç®¡ç† =====
    const input = {
      left: false,
      right: false,
      fire: false,
      mouseX: null
    };

    // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = true;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = true;
      if (e.key === ' ') {
        e.preventDefault();
        input.fire = true;
      }
    });

    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') input.left = false;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') input.right = false;
      if (e.key === ' ') input.fire = false;
    });

    // ãƒã‚¦ã‚¹
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.clientX - rect.left;
    });

    canvas.addEventListener('mouseleave', () => {
      input.mouseX = null;
    });

    canvas.addEventListener('click', () => {
      if (game.state === 'playing' || game.state === 'boss') fireHammer();
    });

    // ã‚¿ãƒƒãƒ
    canvas.addEventListener('touchmove', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.touches[0].clientX - rect.left;
    });

    canvas.addEventListener('touchend', () => {
      input.mouseX = null;
    });

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      input.mouseX = e.touches[0].clientX - rect.left;
      if (game.state === 'playing' || game.state === 'boss') fireHammer();
    });

    // ===== ãƒãƒ³ãƒãƒ¼ =====
    function fireHammer() {
      const now = Date.now();
      if (now - game.lastHammer < CONFIG.HAMMER_COOLDOWN) return;
      game.lastHammer = now;

      const currentPhase = CONFIG.PHASES[game.phase];

      // åŸºæœ¬ãƒãƒ³ãƒãƒ¼
      game.hammers.push({
        x: player.x,
        y: player.y - 30,
        vx: 0,
        vy: -CONFIG.HAMMER_SPEED,
        rotation: 0
      });

      // æ‹¡æ•£æ”»æ’ƒï¼ˆãƒ•ã‚§ãƒ¼ã‚º2ä»¥é™ï¼‰
      if (currentPhase.spread) {
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: -3,
          vy: -CONFIG.HAMMER_SPEED,
          rotation: 0
        });
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: 3,
          vy: -CONFIG.HAMMER_SPEED,
          rotation: 0
        });
      }

      // å¼¾å¹•ãƒ¢ãƒ¼ãƒ‰ï¼ˆãƒ•ã‚§ãƒ¼ã‚º3ï¼‰
      if (currentPhase.barrage) {
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: -6,
          vy: -CONFIG.HAMMER_SPEED * 0.8,
          rotation: 0
        });
        game.hammers.push({
          x: player.x,
          y: player.y - 30,
          vx: 6,
          vy: -CONFIG.HAMMER_SPEED * 0.8,
          rotation: 0
        });
      }
    }

    function updateHammers() {
      for (let i = game.hammers.length - 1; i >= 0; i--) {
        const h = game.hammers[i];
        h.x += h.vx;
        h.y += h.vy;
        h.rotation += 0.3;

        if (h.y < -30 || h.x < -30 || h.x > width + 30) {
          game.hammers.splice(i, 1);
        }
      }
    }

    function drawHammers() {
      game.hammers.forEach(h => {
        ctx.save();
        ctx.translate(h.x, h.y);
        ctx.rotate(h.rotation);

        // æŸ„
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(-3, -15, 6, 30);

        // é ­
        ctx.fillStyle = '#444';
        ctx.fillRect(-12, -20, 24, 12);

        ctx.restore();
      });
    }

    // ===== ç…©æ‚© =====
    function spawnBonnou() {
      const currentPhase = CONFIG.PHASES[game.phase];
      const count = currentPhase.spawnCount || 1;

      for (let i = 0; i < count; i++) {
        const type = CONFIG.BONNOU_TYPES[Math.floor(Math.random() * CONFIG.BONNOU_TYPES.length)];
        game.bonnous.push({
          x: Math.random() * (width - 60) + 30,
          y: -50 - (i * 40),
          type: type,
          angle: Math.random() * Math.PI * 2,
          time: 0
        });
      }
    }

    function updateBonnous() {
      for (let i = game.bonnous.length - 1; i >= 0; i--) {
        const b = game.bonnous[i];
        b.time++;

        switch (b.type.behavior) {
          case 'normal':
          case 'large':
            b.y += b.type.speed;
            break;
          case 'fast':
            b.y += b.type.speed;
            // é«˜é€Ÿã‚¿ã‚¤ãƒ—ã¯å°‘ã—å·¦å³ã«ãƒ–ãƒ¬ã‚‹
            b.x += (Math.random() - 0.5) * 2;
            break;
          case 'homing':
            const dx = player.x - b.x;
            // å¼·åŠ›ãªè¿½å°¾ï¼ˆè·é›¢ã«å¿œã˜ã¦åŠ é€Ÿï¼‰
            const homingStrength = Math.min(3, Math.abs(dx) * 0.02);
            b.x += Math.sign(dx) * homingStrength;
            b.y += b.type.speed;
            break;
          case 'wave':
            b.angle += 0.08;
            b.x += Math.sin(b.angle) * 5;
            b.y += b.type.speed;
            break;
        }

        // ç”»é¢å†…ã«åˆ¶é™ï¼ˆå·¦å³ï¼‰
        b.x = Math.max(b.type.size, Math.min(width - b.type.size, b.x));

        // ç”»é¢å¤–ã§å‰Šé™¤
        if (b.y > height + 50) {
          game.bonnous.splice(i, 1);
        }
      }
    }

    function drawBonnous() {
      game.bonnous.forEach(b => {
        ctx.save();
        ctx.translate(b.x, b.y);

        // ç…©æ‚©ã®ä½“ï¼ˆã‚‚ã‚„ã‚‚ã‚„ï¼‰
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, b.type.size);
        gradient.addColorStop(0, b.type.color);
        gradient.addColorStop(0.7, b.type.color + '88');
        gradient.addColorStop(1, 'transparent');

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, b.type.size, 0, Math.PI * 2);
        ctx.fill();

        // ç…©æ‚©ã®æ–‡å­—
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${b.type.size * 0.6}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.type.name, 0, 0);

        ctx.restore();
      });
    }

    // ===== è¡çªåˆ¤å®š =====
    function checkCollisions() {
      // ãƒãƒ³ãƒãƒ¼ vs ç…©æ‚©
      for (let hi = game.hammers.length - 1; hi >= 0; hi--) {
        const h = game.hammers[hi];
        for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
          const b = game.bonnous[bi];
          const dx = h.x - b.x;
          const dy = h.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < b.type.size + 10) {
            // ç…©æ‚©ã‚’å€’ã—ãŸ
            game.hammers.splice(hi, 1);
            game.bonnous.splice(bi, 1);
            game.bellCount++;

            // é˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            game.bellRings.push({
              x: b.x,
              y: b.y,
              radius: 0,
              alpha: 1
            });

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
            for (let p = 0; p < 8; p++) {
              game.particles.push({
                x: b.x,
                y: b.y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                color: b.type.color,
                life: 30
              });
            }

            // UIæ›´æ–°
            document.getElementById('bellCount').textContent = game.bellCount;

            // ãƒ•ã‚§ãƒ¼ã‚ºãƒã‚§ãƒƒã‚¯
            checkPhase();

            // ãƒœã‚¹æˆ¦ã¸ç§»è¡Œ
            if (game.bellCount >= CONFIG.MAX_BELLS && game.state === 'playing') {
              startBossBattle();
            }

            break;
          }
        }
      }

      // ç…©æ‚© vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
        const b = game.bonnous[bi];
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < b.type.size + 20) {
          game.bonnous.splice(bi, 1);
          game.lives--;
          document.getElementById('lives').textContent = game.lives;

          // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          for (let p = 0; p < 12; p++) {
            game.particles.push({
              x: player.x,
              y: player.y,
              vx: (Math.random() - 0.5) * 10,
              vy: (Math.random() - 0.5) * 10,
              color: '#ff0000',
              life: 40
            });
          }

          if (game.lives <= 0) {
            gameState('gameover');
          }
        }
      }
    }

    // ===== ãƒœã‚¹æˆ¦ =====
    function startBossBattle() {
      game.state = 'boss';
      game.bonnous = [];
      game.hammers = [];
      boss.init();

      // ãƒœã‚¹ç™»å ´ã‚¢ãƒŠã‚¦ãƒ³ã‚¹
      announcePhase('ç…©æ‚©å¤§é˜ å‡ºç¾ï¼');

      // UIã‚’éš ã™ï¼ˆãƒœã‚¹æˆ¦å°‚ç”¨è¡¨ç¤ºã«ï¼‰
      document.getElementById('phaseDisplay').textContent = 'BOSS BATTLE';
    }

    function checkBossCollisions() {
      // ãƒãƒ³ãƒãƒ¼ vs ãƒœã‚¹
      for (let hi = game.hammers.length - 1; hi >= 0; hi--) {
        const h = game.hammers[hi];
        const dx = h.x - boss.x;
        const dy = h.y - boss.y;

        // ãƒœã‚¹ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆçŸ©å½¢ï¼‰
        if (Math.abs(dx) < CONFIG.BOSS.WIDTH / 2 + 10 &&
            Math.abs(dy) < CONFIG.BOSS.HEIGHT / 2 + 10) {
          game.hammers.splice(hi, 1);
          boss.takeDamage();

          // é˜ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          game.bellRings.push({
            x: h.x,
            y: h.y,
            radius: 0,
            alpha: 1
          });
        }
      }

      // ãƒãƒ³ãƒãƒ¼ vs ç…©æ‚©ï¼ˆãƒœã‚¹æˆ¦ä¸­ã€ã‚«ã‚¦ãƒ³ãƒˆãªã—ï¼‰
      for (let hi = game.hammers.length - 1; hi >= 0; hi--) {
        const h = game.hammers[hi];
        for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
          const b = game.bonnous[bi];
          const dx = h.x - b.x;
          const dy = h.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < b.type.size + 10) {
            game.hammers.splice(hi, 1);
            game.bonnous.splice(bi, 1);

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã¿ï¼ˆç‚¹æ•°ãªã—ï¼‰
            for (let p = 0; p < 6; p++) {
              game.particles.push({
                x: b.x,
                y: b.y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                color: b.type.color,
                life: 25
              });
            }
            break;
          }
        }
      }

      // ç…©æ‚© vs ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆãƒœã‚¹æˆ¦ä¸­ï¼‰
      for (let bi = game.bonnous.length - 1; bi >= 0; bi--) {
        const b = game.bonnous[bi];
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < b.type.size + 20) {
          game.bonnous.splice(bi, 1);
          game.lives--;
          document.getElementById('lives').textContent = game.lives;

          // ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          for (let p = 0; p < 12; p++) {
            game.particles.push({
              x: player.x,
              y: player.y,
              vx: (Math.random() - 0.5) * 10,
              vy: (Math.random() - 0.5) * 10,
              color: '#ff0000',
              life: 40
            });
          }

          if (game.lives <= 0) {
            gameState('gameover');
          }
        }
      }
    }

    // ===== ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç† =====
    function checkPhase() {
      for (let i = CONFIG.PHASES.length - 1; i >= 0; i--) {
        if (game.bellCount >= CONFIG.PHASES[i].start) {
          if (game.phase !== i) {
            game.phase = i;
            announcePhase(CONFIG.PHASES[i].name);
            document.getElementById('phaseDisplay').textContent = CONFIG.PHASES[i].name;
          }
          break;
        }
      }
    }

    function announcePhase(name) {
      const el = document.getElementById('phaseAnnounce');
      el.textContent = name;
      el.style.opacity = 1;
      setTimeout(() => {
        el.style.opacity = 0;
      }, 2000);
    }

    // ===== ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ =====
    function updateParticles() {
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life--;

        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      game.particles.forEach(p => {
        ctx.fillStyle = p.color + Math.floor(p.life / 40 * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function updateBellRings() {
      for (let i = game.bellRings.length - 1; i >= 0; i--) {
        const r = game.bellRings[i];
        r.radius += 5;
        r.alpha -= 0.03;

        if (r.alpha <= 0) {
          game.bellRings.splice(i, 1);
        }
      }
    }

    function drawBellRings() {
      game.bellRings.forEach(r => {
        ctx.strokeStyle = `rgba(255, 215, 0, ${r.alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.stroke();
      });
    }

    // ===== èƒŒæ™¯ï¼ˆæ˜Ÿï¼‰ =====
    function initStars() {
      game.stars = [];
      for (let i = 0; i < 100; i++) {
        game.stars.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2 + 0.5,
          speed: Math.random() * 0.5 + 0.2
        });
      }
    }

    function updateStars() {
      game.stars.forEach(s => {
        s.y += s.speed;
        if (s.y > height) {
          s.y = 0;
          s.x = Math.random() * width;
        }
      });
    }

    function drawStars() {
      ctx.fillStyle = '#fff';
      game.stars.forEach(s => {
        ctx.globalAlpha = 0.5 + Math.random() * 0.5;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    // ===== ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç† =====
    function gameState(state) {
      game.state = state;

      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('clearScreen').classList.add('hidden');

      switch (state) {
        case 'start':
          document.getElementById('startScreen').classList.remove('hidden');
          break;
        case 'playing':
          resetGame();
          break;
        case 'gameover':
          document.getElementById('finalBellCount').textContent = game.bellCount;
          document.getElementById('gameOverScreen').classList.remove('hidden');
          break;
        case 'clear':
          document.getElementById('clearScreen').classList.remove('hidden');
          break;
      }
    }

    function resetGame() {
      game.bellCount = 0;
      game.lives = CONFIG.INITIAL_LIVES;
      game.phase = 0;
      game.lastSpawn = 0;
      game.lastHammer = 0;
      game.hammers = [];
      game.bonnous = [];
      game.particles = [];
      game.bellRings = [];

      player.init();
      initStars();

      document.getElementById('bellCount').textContent = '0';
      document.getElementById('lives').textContent = game.lives;
      document.getElementById('phaseDisplay').textContent = CONFIG.PHASES[0].name;
    }

    // ===== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— =====
    function gameLoop(timestamp) {
      // èƒŒæ™¯ã‚¯ãƒªã‚¢
      ctx.fillStyle = '#0a0a2e';
      ctx.fillRect(0, 0, width, height);

      // æ˜Ÿ
      updateStars();
      drawStars();

      if (game.state === 'playing') {
        // ç…©æ‚©ã‚¹ãƒãƒ¼ãƒ³
        const currentPhase = CONFIG.PHASES[game.phase];
        if (timestamp - game.lastSpawn > currentPhase.spawnRate) {
          spawnBonnou();
          game.lastSpawn = timestamp;
        }

        // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é€£å°„
        if (input.fire) {
          fireHammer();
        }

        // æ›´æ–°
        player.update();
        updateHammers();
        updateBonnous();
        checkCollisions();
        updateParticles();
        updateBellRings();

        // æç”»
        drawBonnous();
        drawHammers();
        player.draw();
        drawParticles();
        drawBellRings();
      }

      if (game.state === 'boss') {
        // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é€£å°„
        if (input.fire) {
          fireHammer();
        }

        // æ›´æ–°
        player.update();
        updateHammers();
        updateBonnous();
        boss.update(timestamp);
        checkBossCollisions();
        updateParticles();
        updateBellRings();

        // æç”»
        drawBonnous();
        boss.draw();
        drawHammers();
        player.draw();
        drawParticles();
        drawBellRings();
      }

      requestAnimationFrame(gameLoop);
    }

    // ===== åˆæœŸåŒ– =====
    function init() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      initStars();
      player.init();

      // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
      document.getElementById('startButton').addEventListener('click', () => gameState('playing'));
      document.getElementById('retryButton').addEventListener('click', () => gameState('playing'));
      document.getElementById('clearRetryButton').addEventListener('click', () => gameState('playing'));

      gameState('start');
      requestAnimationFrame(gameLoop);
    }

    init();
  </script>
</body>
</html>
